#!/usr/bin/env -S npx ts-node
import { compile } from 'json-schema-to-typescript';
import fs from 'fs-extra';
import _ from 'lodash';
import { JSONSchema4 } from 'json-schema';
import path from 'path';

const schemaExtension = '.schema.json';
const dtsWorkingDir: string = path.resolve('default-file-types-temp');
const dtsTargetDir = path.resolve('src/default-file-types');

const findFiles = async (filePath: string, result: string[] = []) => {
    const fileStats = await fs.promises.lstat(filePath);
    if (fileStats.isDirectory()) {
        const files = await fs.promises.readdir(filePath);
        const promises = files.map(async (listFilePath: string) => {
            const resultPath = path.resolve(path.join(filePath, listFilePath));
            await findFiles(resultPath, result);
        });
        await Promise.all(promises);
    } else if (fileStats.isSymbolicLink()) {
        console.debug(`findFiles: skipping symbolic link: ${filePath}`);
    } else if (fileStats.isFile()) {
        if (filePath.endsWith(schemaExtension)) {
            result.push(filePath);
        }
    } else if (fileStats.isSymbolicLink()) {
        console.debug(`recursiveListFilesInDirectory: skipping symbolic link: ${filePath}`);
    } else {
        console.error(`recursiveListFilesInDirectory: not a file, symbolic link, or directory: ${filePath}`);
    }
    return result;
}
const generateValidatedTypeFile = async (filePath: string) => {
  const dirname = path.dirname(filePath);
  const filename = path.basename(filePath, schemaExtension);
  const thisDtsDir = path.join(dtsWorkingDir, 'types');
  const newPath = path.join(thisDtsDir, `${filename}.d.ts`);

  console.log(`Writing validated type file: ${newPath}`);
  // TODO reference this script in the message
  await fs.promises.writeFile(newPath, `/* eslint-disable @typescript-eslint/no-empty-interface */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* tslint:disable */
/**
* This file was automatically generated by json-schema-to-typescript.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run json-schema-to-typescript to regenerate this file.
*/
`);

  let state: 'READY' | 'READ' | 'COMPILED' | 'INDEXING' | 'FINISHED' = 'READY';
  try {
    // Dynamic require (using this to read the file)
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const schema = require(filePath) as JSONSchema4;
    state = 'READ';
    const interfaceName = `I${_.upperFirst(filename)}`;
    const ts = await compile(schema, interfaceName, {
      bannerComment: '',
      cwd: path.dirname(newPath),
      style: {
        singleQuote: true
      }
    });
    state = 'COMPILED';
    // const defaultTS = `export default ${ts.substring('export '.length)}`;
    // await fs.promises.appendFile(newPath, defaultTS + '\n');
    await fs.promises.appendFile(newPath, `${ts}\n`);
    await fs.promises.appendFile(newPath, `export default ${interfaceName};\n`);
    state = 'INDEXING';
    await fs.promises.appendFile(path.join(thisDtsDir, '../index.d.ts'), `export { default as ${interfaceName} } from './types/${filename}';\n`);

    // NOT used
    state = 'FINISHED';
  } catch (catchOneErr) {
    console.error(`Failed to read "${filePath}" compile it and write it to "${newPath}" at state "${state}"`, catchOneErr);
    throw catchOneErr;
  }
};

(async () => {
  try {
    if (dtsWorkingDir) {
        if (fs.existsSync(dtsWorkingDir)) {
            await fs.remove(dtsWorkingDir);
        }
        await fs.mkdirp(dtsWorkingDir);
        fs.mkdirSync(path.join(dtsWorkingDir, 'types'));
    }

    const filePaths = await findFiles('./assets/default-file-schemas', []);
    const promises = filePaths.map(generateValidatedTypeFile);
    await Promise.all(promises);

    if (dtsTargetDir) {
        if (fs.existsSync(dtsTargetDir)) {
            await fs.remove(dtsTargetDir);
        }
        await fs.move(dtsWorkingDir, dtsTargetDir);
    }
  } catch (catchAllErr) {
    console.error('Failed', catchAllErr);
  }
})();